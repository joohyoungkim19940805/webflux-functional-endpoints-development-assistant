package com.byeolnaerim.watch.db;


import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import com.byeolnaerim.watch.AbstractWatcher;
import com.byeolnaerim.watch.ProjectDefaults;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import spoon.Launcher;
import spoon.compiler.Environment;
import spoon.reflect.code.CtExpression;
import spoon.reflect.code.CtLiteral;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtField;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.visitor.filter.AbstractFilter;
import spoon.support.JavaOutputProcessor;


public class EntityFileWatcher extends AbstractWatcher {

	// ====== Field raw-name annotation candidates (no dependency; string match only) ======
	private static final List<String> FIELD_ANNOTATION_CANDIDATES = List
		.of(
			"org.springframework.data.mongodb.core.mapping.Field", // @Field("raw") or @Field(value="raw")
			"org.springframework.data.relational.core.mapping.Column", // @Column("raw") or @Column(value="raw")
			"jakarta.persistence.Column", // @Column(name="raw")
			"javax.persistence.Column", // @Column(name="raw")
			"com.fasterxml.jackson.annotation.JsonProperty" // @JsonProperty("raw")
		);

	private static final Set<String> JAVA_KEYWORDS = Set
		.of(
			"abstract",
			"assert",
			"boolean",
			"break",
			"byte",
			"case",
			"catch",
			"char",
			"class",
			"const",
			"continue",
			"default",
			"do",
			"double",
			"else",
			"enum",
			"extends",
			"final",
			"finally",
			"float",
			"for",
			"goto",
			"if",
			"implements",
			"import",
			"instanceof",
			"int",
			"interface",
			"long",
			"native",
			"new",
			"package",
			"private",
			"protected",
			"public",
			"return",
			"short",
			"static",
			"strictfp",
			"super",
			"switch",
			"synchronized",
			"this",
			"throw",
			"throws",
			"transient",
			"try",
			"void",
			"volatile",
			"while",
			"_",
			"true",
			"false",
			"null"
		);

	// enum constant line patterns:
	// 1) NEW FORMAT: SOME_ID("raw-name"),
	// 2) OLD FORMAT: SOME_ID,
	private static final Pattern ENUM_CONST_WITH_RAW = Pattern
		.compile(
			"^\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*\\(\\s*\"((?:\\\\.|[^\"\\\\])*)\"\\s*\\)\\s*[,;]\\s*$"
		);

	private static final Pattern ENUM_CONST_ID_ONLY = Pattern
		.compile(
			"^\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*[,;]\\s*$"
		);

	private static final String ENUM_TEMPLATE_WITH_PKG = """
		package %s;

		%spublic enum %s {
		%s

		    private final String rawName;

		    %s(String rawName) {
		        this.rawName = rawName;
		    }

		    public String getRawName() {
		        return this.rawName;
		    }

		    @Override
		    public String toString() {
		        return this.rawName;
		    }
		}
		""";

	private static final String ENUM_TEMPLATE_NO_PKG = """
		%spublic enum %s {
		%s

		    private final String rawName;

		    %s(String rawName) {
		        this.rawName = rawName;
		    }

		    public String getRawName() {
		        return this.rawName;
		    }

		    @Override
		    public String toString() {
		        return this.rawName;
		    }
		}
		""";

	private static String buildGeneratedJavadoc(
		String see
	) {

		String seeLine = (see == null || see.isBlank()) ? "" : " * @see " + see + "\n";
		return """
			/**
			 * Generated by script, do not edit manually
			%s */
			""".formatted( seeLine );

	}

	private static CtAnnotation<?> findTargetAnnotation(
		CtClass<?> ctClass, String targetAnnotationName
	) {

		if (ctClass == null)
			return null;
		if (targetAnnotationName == null || targetAnnotationName.isBlank())
			return null;

		final String target = targetAnnotationName.trim();
		final String targetSimple = target.contains( "." )
			? target.substring( target.lastIndexOf( '.' ) + 1 )
			: target;

		return ctClass
			.getAnnotations()
			.stream()
			.filter( a -> isTargetAnnotation( a, target, targetSimple ) )
			.findFirst()
			.orElse( null );

	}

	private static CtAnnotation<?> findTargetAnnotation(
		CtField<?> ctField, String targetAnnotationName
	) {

		if (ctField == null)
			return null;
		if (targetAnnotationName == null || targetAnnotationName.isBlank())
			return null;

		final String target = targetAnnotationName.trim();
		final String targetSimple = target.contains( "." )
			? target.substring( target.lastIndexOf( '.' ) + 1 )
			: target;

		return ctField
			.getAnnotations()
			.stream()
			.filter( a -> isTargetAnnotation( a, target, targetSimple ) )
			.findFirst()
			.orElse( null );

	}

	private static boolean isTargetAnnotation(
		CtAnnotation<?> ann, String targetFqnOrSimple, String targetSimple
	) {

		if (ann == null || ann.getAnnotationType() == null)
			return false;

		String qn = ann.getAnnotationType().getQualifiedName(); // noClasspath면 비거나 단순명만 올 수도 있음
		String sn = ann.getAnnotationType().getSimpleName();

		if (targetFqnOrSimple.equals( qn ))
			return true;
		if (targetFqnOrSimple.equals( sn ))
			return true;

		// FQN을 넣었는데 Spoon이 simple만 들고 있는 경우 대비
		if (targetSimple.equals( sn ))
			return true;
		if (targetSimple.equals( qn ))
			return true;

		return false;

	}

	private static String firstStringValue(
		CtAnnotation<?> ann, String... keys
	) {

		for (String k : keys) {
			String v = getStringAnnotationValue( ann, k );
			if (v != null && ! v.isBlank())
				return v;

		}

		return null;

	}

	private static String getStringAnnotationValue(
		CtAnnotation<?> ann, String key
	) {

		if (ann == null)
			return null;

		CtExpression<?> expr = ann.getValue( key );
		if (expr == null)
			return null;

		if (expr instanceof CtLiteral<?> lit) {
			Object val = lit.getValue();
			if (val instanceof String s)
				return s;

		}

		// 상수 참조/식일 수도 있으니 문자열로 fallback
		return expr.toString();

	}

	private static String resolveEntityStorageName(
		CtClass<?> ctClass, String targetAnnotationName
	) {

		CtAnnotation<?> ann = findTargetAnnotation( ctClass, targetAnnotationName );
		if (ann == null)
			return null;

		// Mongo @Document: collection/value(alias)
		// Relational @Table: value
		// JPA @Table: name
		String v = firstStringValue( ann, "collection", "value", "name" );
		if (v != null && ! v.isBlank())
			return v;

		return ctClass != null ? ctClass.getSimpleName() : null;

	}

	private static String resolveFieldStorageName(
		CtFieldReference<?> fieldRef
	) {

		if (fieldRef == null)
			return null;

		String fallback = fieldRef.getSimpleName();
		CtField<?> decl = fieldRef.getDeclaration();
		if (decl == null)
			return fallback;

		for (String annName : FIELD_ANNOTATION_CANDIDATES) {
			CtAnnotation<?> ann = findTargetAnnotation( decl, annName );
			if (ann == null)
				continue;

			// @Field("x") -> value
			// @Column(name="x") -> name
			// @Column("x") -> value
			// @JsonProperty("x") -> value
			String raw = firstStringValue( ann, "value", "name" );
			if (raw != null && ! raw.isBlank())
				return raw;

		}

		return fallback;

	}

	private static String toJavaEnumIdentifier(
		String raw
	) {

		if (raw == null)
			return "_NULL";

		String s = raw.trim();
		if (s.isEmpty())
			return "_EMPTY";

		// 공백/하이픈/점 등은 _
		s = s.replaceAll( "[^A-Za-z0-9_]", "_" );

		// 전부 _ 로만 남았으면 해시로 안정화
		if (s.replace( "_", "" ).isEmpty()) {
			s = "_" + Integer.toHexString( raw.hashCode() ).toUpperCase();

		}

		// 첫 글자가 숫자면 _ prefix
		if (Character.isDigit( s.charAt( 0 ) )) {
			s = "_" + s;

		}

		// 키워드면 prefix
		if (JAVA_KEYWORDS.contains( s )) {
			s = "_" + s;

		}

		// 단일 "_"는 Java 9+ reserved
		if ("_".equals( s )) {
			s = "__";

		}

		return s;

	}

	private static String uniqueEnumId(
		Set<String> usedIds, String base
	) {

		String id = base;
		int n = 2;

		while (usedIds.contains( id )) {
			id = base + "_" + (n++);

		}

		usedIds.add( id );
		return id;

	}

	private static String javaStringLiteral(
		String s
	) {

		if (s == null)
			return "null";

		String escaped = s
			.replace( "\\", "\\\\" )
			.replace( "\"", "\\\"" )
			.replace( "\n", "\\n" )
			.replace( "\r", "\\r" )
			.replace( "\t", "\\t" );

		return "\"" + escaped + "\"";

	}

	private static String unescapeJavaString(
		String s
	) {

		// 최소한의 unescape (우리가 escape한 범위만 되돌림)
		if (s == null)
			return null;
		StringBuilder out = new StringBuilder();

		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt( i );

			if (c == '\\' && i + 1 < s.length()) {
				char n = s.charAt( ++i );

				switch (n) {
					case 'n' -> out.append( '\n' );
					case 'r' -> out.append( '\r' );
					case 't' -> out.append( '\t' );
					case '\\' -> out.append( '\\' );
					case '"' -> out.append( '"' );
					default -> out.append( n ); // 알 수 없는 escape는 그냥 문자로

				}

			} else {
				out.append( c );

			}

		}

		return out.toString();

	}

	private static final class EnumConst {

		final String id;

		final String raw;

		EnumConst(
					String id,
					String raw
		) {

			this.id = id;
			this.raw = raw;

		}

	}

	private static final class ParsedEnumFile {

		final List<EnumConst> ordered; // 파일에 있던 순서 유지

		final Map<String, String> rawToId; // rawName -> enumId (가능한 경우)

		final Set<String> usedIds; // enumId set

		ParsedEnumFile(
						List<EnumConst> ordered,
						Map<String, String> rawToId,
						Set<String> usedIds
		) {

			this.ordered = ordered;
			this.rawToId = rawToId;
			this.usedIds = usedIds;

		}

	}

	private static ParsedEnumFile parseExistingEnumFile(
		Path file
	) {

		if (file == null || ! Files.exists( file )) { return new ParsedEnumFile( new ArrayList<>(), new HashMap<>(), new HashSet<>() ); }

		try {
			List<String> lines = Files.readAllLines( file, StandardCharsets.UTF_8 );
			List<EnumConst> ordered = new ArrayList<>();
			Map<String, String> rawToId = new HashMap<>();
			Set<String> used = new HashSet<>();

			for (String line : lines) {
				Matcher m1 = ENUM_CONST_WITH_RAW.matcher( line );

				if (m1.matches()) {
					String id = m1.group( 1 );
					String rawEscaped = m1.group( 2 );
					String raw = unescapeJavaString( rawEscaped );

					ordered.add( new EnumConst( id, raw ) );
					used.add( id );
					if (raw != null)
						rawToId.put( raw, id );
					continue;

				}

				Matcher m2 = ENUM_CONST_ID_ONLY.matcher( line );

				if (m2.matches()) {
					String id = m2.group( 1 );
					ordered.add( new EnumConst( id, id ) ); // raw를 모르니 id로 대체
					used.add( id );

				}

			}

			return new ParsedEnumFile( ordered, rawToId, used );

		} catch (IOException e) {
			// 파싱 실패하면 그냥 빈 상태로
			return new ParsedEnumFile( new ArrayList<>(), new HashMap<>(), new HashSet<>() );

		}

	}

	private static String renderEnumSource(
		String pkg, String enumName, String comments, List<EnumConst> constants
	) {

		String constantsBlock;

		if (constants == null || constants.isEmpty()) {
			constantsBlock = "    ;";

		} else {
			String joined = constants
				.stream()
				.map( c -> "    " + c.id + "(" + javaStringLiteral( c.raw ) + ")" )
				.collect( Collectors.joining( ",\n" ) );
			constantsBlock = joined + ";";

		}

		String commentBlock = (comments == null) ? "" : comments;
		if (! commentBlock.isEmpty() && ! commentBlock.endsWith( "\n" ))
			commentBlock += "\n";

		if (pkg != null && ! pkg.isBlank()) { return ENUM_TEMPLATE_WITH_PKG.formatted( pkg, commentBlock, enumName, constantsBlock, enumName ); }

		return ENUM_TEMPLATE_NO_PKG.formatted( commentBlock, enumName, constantsBlock, enumName );

	}

	public static final class Config {

		private final String collectionNameEnum;

		private final String collectionNamePackage;

		private final String rootPath;

		private final String fieldPackage;

		private final String entityPackage;

		private final String webfluxDocumentName;

		private Config(
						Builder b
		) {

			this.collectionNameEnum = b.collectionNameEnum;
			this.collectionNamePackage = b.collectionNamePackage.replace( '\\', '/' ).replace( '/', '.' );
			this.rootPath = b.rootPath.replace( '\\', '/' ).replace( '.', '/' );
			this.fieldPackage = b.fieldPackage.replace( '\\', '/' ).replace( '/', '.' );
			this.entityPackage = b.entityPackage.replace( '\\', '/' ).replace( '/', '.' );
			this.webfluxDocumentName = b.webfluxDocumentName;

		}
		// getters...

		public static Builder builder() {

			return new Builder();

		}

		public static final class Builder {

			private String collectionNameEnum = "CollectionNames"; // 필요시 변경

			private String collectionNamePackage = ProjectDefaults.COLLECTION_NAME_PACKAGE; // dot

			private String rootPath = ProjectDefaults.SRC_MAIN_JAVA; // slash

			private String fieldPackage = ProjectDefaults.FIELD_PACKAGE; // dot

			private String entityPackage = ProjectDefaults.ENTITY_PACKAGE;

			private String webfluxDocumentName = "org.springframework.data.mongodb.core.mapping.Document";

			public Builder collectionNameEnum(
				String v
			) {

				this.collectionNameEnum = v;
				return this;

			}

			public Builder collectionNamePackage(
				String v
			) {

				this.collectionNamePackage = v;
				return this;

			}

			public Builder rootPath(
				String v
			) {

				this.rootPath = v;
				return this;

			}

			public Builder fieldPackage(
				String v
			) {

				this.fieldPackage = v;
				return this;

			}

			public Builder entityPackage(
				String v
			) {

				this.entityPackage = v;
				return this;

			}

			public Builder webfluxDocumentName(
				String v
			) {

				this.webfluxDocumentName = v;
				return this;

			}

			public Config build() {

				return new Config( this );

			}

		}

	}

	private final Config config;

	protected final File rootDir;

	protected final JavaOutputProcessor javaOutputProcessor = new JavaOutputProcessor();

	public EntityFileWatcher(
								Config config
	) {

		this.config = config;

		Launcher spoon = new Launcher();
		Environment env = spoon.getEnvironment();
		env.setAutoImports( true );
		env.setNoClasspath( true );
		env.setShouldCompile( false );
		env.setComplianceLevel( 14 );

		rootDir = (spoon
			.getEnvironment()
			.getSourceOutputDirectory()
			.getParentFile()
			.toPath()
			.resolve( this.config.rootPath ))
			.toFile();

		env.setSourceOutputDirectory( rootDir );
		spoon.addInputResource( this.config.rootPath );
		spoon.buildModel();

		try {
			Files.createDirectories( rootDir.toPath() );
			Files.createDirectories( rootDir.toPath().resolve( this.config.fieldPackage.replaceAll( "\\.", "/" ) ) );

		} catch (IOException e1) {
			e1.printStackTrace();

		}

	}

	/** 오케스트레이터가 호출할 실제 작업 (한 번 실행) */
	@Override
	public Mono<Boolean> runGenerateTask() {

		return generateFiles();

	}

	/** AbstractWatcher에 감시 루트 제공 */
	@Override
	protected Path root() {

		return rootDir.toPath().resolve( config.entityPackage.replace( '.', '/' ) );

	}

	@Override
	public void startWatching() {

		try {
			super.start();

		} catch (IOException e) {
			throw new RuntimeException( e );

		}

	}

	public Mono<Boolean> generateFiles() {

		Launcher spoon = new Launcher();
		Factory factory = spoon.getFactory();
		Environment env = spoon.getEnvironment();
		env.setAutoImports( true );
		env.setNoClasspath( true );
		env.setShouldCompile( true );
		env.setComplianceLevel( 14 );
		env.setSourceOutputDirectory( rootDir );
		spoon.addInputResource( config.rootPath );
		spoon.buildModel();
		javaOutputProcessor.setFactory( spoon.getFactory() );

		// 엔티티 클래스 필터링
		Flux<CtClass<?>> entities = Mono
			.fromCallable(
				() -> factory
					.Package()
					.getRootPackage()
					.getElements( new AbstractFilter<CtClass<?>>() {

						@Override
						public boolean matches(
							CtClass<?> element
						) {

							return findTargetAnnotation( element, config.webfluxDocumentName ) != null;

						}

					} )
					.stream()
			)
			.map( Flux::fromStream )
			.flatMapMany( f -> f );

		// CollectionNames enum 파일 경로
		String collectionEnumQname = config.collectionNamePackage + "." + config.collectionNameEnum;
		Path collectionEnumPath = Paths
			.get(
				config.rootPath,
				config.collectionNamePackage.replace( '.', '/' ),
				config.collectionNameEnum + ".java"
			);

		ParsedEnumFile existingCollections = parseExistingEnumFile( collectionEnumPath );

		// in-memory 상태: rawName -> id, usedIds, ordered list(기존 유지)
		Map<String, String> collectionRawToId = new HashMap<>( existingCollections.rawToId );
		Set<String> collectionUsedIds = new HashSet<>( existingCollections.usedIds );
		List<EnumConst> collectionOrdered = new ArrayList<>( existingCollections.ordered );

		// entity loop
		Mono<Boolean> fieldsChanged = entities
			.flatMap( ctClass -> Mono.fromCallable( () -> {

				// ===== Fields enum build =====
				String fieldsEnumName = ctClass.getSimpleName() + "Fields";
				String fieldsEnumPkg = config.fieldPackage;
				Path fieldsEnumPath = Paths
					.get(
						config.rootPath,
						fieldsEnumPkg.replace( '.', '/' ),
						fieldsEnumName + ".java"
					);

				ParsedEnumFile existingFields = parseExistingEnumFile( fieldsEnumPath );
				Map<String, String> fieldRawToId = new HashMap<>( existingFields.rawToId );
				Set<String> fieldUsedIds = new HashSet<>( existingFields.usedIds );
				List<EnumConst> fieldOrdered = new ArrayList<>( existingFields.ordered );

				// field refs 수집
				Map<String, CtFieldReference<?>> dedup = Stream
					.concat(
						(ctClass.getAllFields() == null) ? Stream.empty() : ctClass.getAllFields().stream(),
						(ctClass.getSuperclass() == null || ctClass.getSuperclass().getAllFields() == null)
							? Stream.empty()
							: ctClass.getSuperclass().getAllFields().stream()
					)
					.collect( Collectors.toMap( CtFieldReference::getSimpleName, fr -> fr, (a, b) -> a ) );

				List<CtFieldReference<?>> fieldRefs = dedup
					.values()
					.stream()
					.sorted( Comparator.comparing( CtFieldReference::getSimpleName ) )
					.toList();

				// 새로 추가될 raw 필드명들
				List<String> rawFieldNames = fieldRefs
					.stream()
					.map( fr -> {
						String raw = resolveFieldStorageName( fr );
						return (raw == null || raw.isBlank()) ? fr.getSimpleName() : raw;

					} )
					.distinct()
					.sorted()
					.toList();

				// rawName 기준으로 기존 id 재사용, 없으면 새 id 생성
				for (String raw : rawFieldNames) {

					if (fieldRawToId.containsKey( raw )) {
						// 기존에 이미 raw->id가 있으면, ordered에 있든 없든 유지
						continue;

					}

					String baseId = toJavaEnumIdentifier( raw );
					String id = uniqueEnumId( fieldUsedIds, baseId );
					fieldRawToId.put( raw, id );
					fieldOrdered.add( new EnumConst( id, raw ) );

				}

				String fieldsComments = buildGeneratedJavadoc( ctClass.getQualifiedName() );
				String fieldsCode = renderEnumSource( fieldsEnumPkg, fieldsEnumName, fieldsComments, fieldOrdered );

				boolean fieldsFileChanged = writeIfChanged( fieldsEnumPath, fieldsCode.getBytes( StandardCharsets.UTF_8 ) );

				String collectionRaw = resolveEntityStorageName( ctClass, config.webfluxDocumentName );

				if (collectionRaw != null && ! collectionRaw.isBlank()) {

					if (! collectionRawToId.containsKey( collectionRaw )) {
						String baseId = toJavaEnumIdentifier( collectionRaw );

						// baseId가 이미 쓰이고 있으면 suffix로 충돌 회피
						String id = uniqueEnumId( collectionUsedIds, baseId );

						collectionRawToId.put( collectionRaw, id );
						collectionOrdered.add( new EnumConst( id, collectionRaw ) );

					}

				}

				return fieldsFileChanged;

			} ) )
			.reduce( false, (acc, ch) -> acc || ch )
			.defaultIfEmpty( false );

		Mono<Boolean> collectionsChanged = fieldsChanged.flatMap( any -> Mono.fromCallable( () -> {
			String collectionComments = buildGeneratedJavadoc( collectionEnumQname );
			String collectionCode = renderEnumSource(
				config.collectionNamePackage,
				config.collectionNameEnum,
				collectionComments,
				collectionOrdered
			);

			boolean changed = writeIfChanged( collectionEnumPath, collectionCode.getBytes( StandardCharsets.UTF_8 ) );
			return changed;

		} ) ).defaultIfEmpty( false );

		return Mono.zip( fieldsChanged, collectionsChanged ).map( t -> t.getT1() || t.getT2() );

	}

}
